# 代码生成实验一设计报告

——18373528杨凌华

#### 一、本次实验涉及到的文法内容

输入文件：testfile.txt	输出文件：mips.txt	中文编码格式：UTF-8

1）**常量说明**

```pascal
＜常量说明＞ ::= const＜常量定义＞;{ const＜常量定义＞;}
＜常量定义＞ ::= int＜标识符＞＝＜整数＞{,＜标识符＞＝＜整数＞} | char＜标识符＞＝＜字符＞{,＜标识符＞＝＜字符＞}

＜标识符＞ ::= ＜字母＞｛＜字母＞｜＜数字＞｝
＜整数＞ ::=［＋｜－］＜无符号整数＞
＜字符＞ ::= '＜加法运算符＞'｜'＜乘法运算符＞'｜'＜字母＞'｜'＜数字＞'

＜无符号整数＞ ::= ＜数字＞｛＜数字＞｝
＜字母＞ ::= ＿｜a｜．．．｜z｜A｜．．．｜Z
＜数字＞ ::= ０｜１｜．．．｜９
＜加法运算符＞ ::= +｜-
＜乘法运算符＞ ::= *｜/
```

2）**变量说明**

```pascal
＜变量说明＞ ::= ＜变量定义＞;{＜变量定义＞;}
＜变量定义＞ ::= ＜变量定义无初始化＞|＜变量定义及初始化＞

＜变量定义无初始化＞ ::= ＜类型标识符＞(＜标识符＞){,(＜标识符＞)}
＜变量定义及初始化＞ ::= ＜类型标识符＞＜标识符＞=＜常量＞

＜类型标识符＞ ::= int | char
＜标识符＞ ::= ＜字母＞｛＜字母＞｜＜数字＞｝
＜常量＞ ::= ＜整数＞|＜字符＞

＜整数＞ ::=［＋｜－］＜无符号整数＞
＜字符＞ ::= '＜加法运算符＞'｜'＜乘法运算符＞'｜'＜字母＞'｜'＜数字＞'
＜字母＞ ::= ＿｜a｜．．．｜z｜A｜．．．｜Z
＜数字＞ ::= ０｜１｜．．．｜９

＜无符号整数＞ ::= ＜数字＞｛＜数字＞｝
＜加法运算符＞ ::= +｜-
＜乘法运算符＞ ::= *｜/
```

3）**读语句**

```pascal
＜读语句＞ ::= scanf '('＜标识符＞')'

＜标识符＞ ::= ＜字母＞｛＜字母＞｜＜数字＞｝
＜字母＞ ::= ＿｜a｜．．．｜z｜A｜．．．｜Z
＜数字＞ ::= ０｜１｜．．．｜９
```

4）**写语句**

```pascal
＜写语句＞ ::= printf'('＜字符串＞,＜表达式＞')'| printf'('＜字符串＞')'| printf'('＜表达式＞')'

＜字符串＞ ::= "｛十进制编码为32,33,35-126的ASCII字符｝"
＜表达式＞ ::= ［＋｜－］＜项＞{＜加法运算符＞＜项＞}

＜项＞ ::= ＜因子＞{＜乘法运算符＞＜因子＞}
＜加法运算符＞ ::= +｜-

＜因子＞ ::= ＜标识符＞ | '('＜表达式＞')'｜＜整数＞|＜字符＞
＜乘法运算符＞ ::= *｜/
```

5）**赋值语句**

```pascal
＜赋值语句＞ ::= ＜标识符＞＝＜表达式＞

＜标识符＞ ::= ＜字母＞｛＜字母＞｜＜数字＞｝
＜表达式＞ ::= ［＋｜－］＜项＞{＜加法运算符＞＜项＞}

＜字母＞ ::= ＿｜a｜．．．｜z｜A｜．．．｜Z
＜数字＞ ::= ０｜１｜．．．｜９
＜项＞ ::= ＜因子＞{＜乘法运算符＞＜因子＞}
＜加法运算符＞ ::= +｜-

＜因子＞ ::= ＜标识符＞ | '('＜表达式＞')'｜＜整数＞|＜字符＞
＜乘法运算符＞ ::= *｜/
```

6）**无函数定义及调用**：nice

7）**无数组声明及引用**：nice

#### 二、注意事项

a）需自行设计**四元式中间代码**，再从中间代码生成MIPS汇编，需设计实现**输出**中间代码的有关函数，本次作业不考核，后续会有优化前后中间代码的输出及评判(输出文件命名为 学号\_姓名\_优化前/后中间代码.txt )。

b）后续的作业需参加竞速排序，需提前预留**代码优化有关的接口**，并设计方便**切换开启/关闭优化的模式**

#### 三、针对本次实验的设计

**1）四元式格式设计：**

| 解释说明 |  op  |  x   |  y   | ans  |
| :------: | :--: | :--: | :--: | :--: |
|  赋值I   |  op  |  x   |  y   | ans  |
|  赋值II  |      |      |      |      |
|          |      |      |      |      |



|                           |   ans    |         x          |      op       |       y       |
| :-----------------------: | :------: | :----------------: | :-----------: | :-----------: |
|           赋值I           |   ans    |         x          |      op       |       y       |
|          赋值II           |   ans    |         x          |               |               |
|          赋值IV           |   ans    |         x          |     addi      |       y       |
|                           |          |                    |               |               |
|          赋值III          |   ans    |                    |       -       |       y       |
|       if语句表达式        |  label   |         x          |     cmpOp     |       y       |
|         标签语句          |  label   |                    |       :       |               |
|         语句跳转          |  label   |                    |       j       |               |
|         函数调用          |  label   |                    |      jal      |               |
|        返回值设置         | <标识符> |                    |    return     |               |
|      把$v0返还存内存      |   ans    |                    |      $v0      |               |
|         返回跳转          |          |                    |      jr       |               |
|        开辟栈空间         |          |     size(数值)     |    spAlloc    |               |
|        回收栈空间         |          |     size(数值)     |    spFree     |               |
|         参数压栈          |  value   |       offset       |    spPush     |               |
|          $ra压栈          |          |                    |    raPush     |               |
|          $ra出栈          |          |                    |     raPop     |               |
|        从栈中取值         |   ans    |       offset       |     spGET     |               |
|        向栈中存值         |  value   |       offset       |     spSET     |               |
| 函数中读语句将$v0存入栈中 |   $v0    |    offset(数值)    |   spSET$v0    |               |
|       数组赋值压栈        |  value   |       offset       |   spARRSET    |               |
|       数组赋值出栈        |   ans    |       offset       |   spARRGET    |               |
|        用数组赋值         |   ans    |       数组名       |    ARRGET     |    offset     |
|    数组被赋值(by变量)     |  value   |       数组名       |  ARRSETbyVAR  |  offset(VAR)  |
|    数组被赋值(by常量)     |  value   |       数组名       | ARRSETbyCONST | offset(CONST) |
|          读语句           |   ans    |                    |     read      |               |
|    读语句（特定类型）     |          |        type        |  ReadByType   |               |
|          写语句I          |          | ＜字符串＞(标识符) |     print     |  ＜表达式＞   |
|         写语句II          |          | ＜字符串＞(标识符) |     print     |               |
|         写语句III         |          |                    |     print     |  ＜表达式＞   |

部分中间代码对照图：

![image-20201111211947576](C:\Users\yang\AppData\Roaming\Typora\typora-user-images\image-20201111211947576.png)

**2）存储管理设计：**

​		为了优先保证基本正确性得到满足，本次实验设计先暂且牺牲一定的效率，进一步的优化放在之后再进行，本次实验暂且没有充分利用寄存器的存储功能，而是将所有变量、常量、字符串都存储在以0x10010000 (将该基地址值始终保存在 $t0 寄存器中) 为起始的内存空间中，只进行运算时，将其分别 lw 给 \$t2 和 \$t3 寄存器，并将运算结果保存在 \$t1 寄存器中，然后将 \$t1 寄存器的值 sw 到内存中或者输出。

**3）符号表设计：**

​		本次实验额外分别建立了一个**代码生成专用符号表** 和 一个**字符串记录表**，前者专门存储本次实验定义的常变量以及复杂表达式拆解过程中用到的中间变量，对于每一个表项，主要记录数据类型和在内存中相对于基地址0x10010000的地址偏移；后者记录本次所有printf语句中需要输出的字符串，对于每一个表项，主要记录该字符串的标识符、内容、在内存中的起始地址相对于基地址0x10010000的偏移值，字符串的长度(按字节计)。

​		因为本次作业是建立在错误处理通过的基础之上的，因此不会出现变、常量名未定义或者重定义的情况，因此当用到某一个量时，就在本次新建的符号表中由后往前遍历查找对应标识符的表项。

 		值得注意的是，因为在复杂表达式拆解过程当中会产生许多中间量，其标识符的命名需要避免与程序本身定义的常量、变量名冲突，唯一的办法就是采用与一般标识符不同的命名规范，我的做法是在标识符之前加一个'~'波浪符以示区分。

**4）复杂表达式的处理**

​		本次语义分析的过程与语法分析的流程相融合，采用课上所讲的语法制导属性翻译文法，对每个与表达式计算相关的递归子程序，添加参数传入与返回值，从而以递归的方式对复杂表达式进行拆解，实现起来改动较小，极为方便，稍加细心便不会出错。

#### 四、针对更多语法成分所进行的设计







附录：

| REGISTER | NAME      | USAGE                     |
| -------- | --------- | ------------------------- |
| $0       | $zero     | 常量0                     |
| $1       | $at       | 保留给汇编器              |
| \$2-$3   | \$v0-​\$v1 | 函数调用返回值            |
| \$4-$7   | \$a0-​\$a3 | 函数调用参数              |
| \$8-$15  | \$t0-$t7  | 临时寄存器                |
| \$16-$23 | \$s0-$s7  | 全局寄存器                |
| \$24-$25 | \$t8-$t9  | 临时寄存器                |
| $28      | $gp       | 全局指针(Global  Pointer) |
| $29      | $sp       | 堆栈指针(Stack  Pointer)  |
| $30      | $fp       | 帧指针(Frame  Pointer)    |
| $31      | $ra       | 返回地址(return  address) |
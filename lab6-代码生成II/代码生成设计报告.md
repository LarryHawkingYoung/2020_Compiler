# 代码生成阶段设计报告

——18373528杨凌华

## 阶段一

#### 一、本次实验涉及到的文法内容

输入文件：testfile.txt	输出文件：mips.txt	中文编码格式：UTF-8

1）**常量说明**

```pascal
＜常量说明＞ ::= const＜常量定义＞;{ const＜常量定义＞;}
＜常量定义＞ ::= int＜标识符＞＝＜整数＞{,＜标识符＞＝＜整数＞} | char＜标识符＞＝＜字符＞{,＜标识符＞＝＜字符＞}

＜标识符＞ ::= ＜字母＞｛＜字母＞｜＜数字＞｝
＜整数＞ ::=［＋｜－］＜无符号整数＞
＜字符＞ ::= '＜加法运算符＞'｜'＜乘法运算符＞'｜'＜字母＞'｜'＜数字＞'

＜无符号整数＞ ::= ＜数字＞｛＜数字＞｝
＜字母＞ ::= ＿｜a｜．．．｜z｜A｜．．．｜Z
＜数字＞ ::= ０｜１｜．．．｜９
＜加法运算符＞ ::= +｜-
＜乘法运算符＞ ::= *｜/
```

2）**变量说明**

```pascal
＜变量说明＞ ::= ＜变量定义＞;{＜变量定义＞;}
＜变量定义＞ ::= ＜变量定义无初始化＞|＜变量定义及初始化＞

＜变量定义无初始化＞ ::= ＜类型标识符＞(＜标识符＞){,(＜标识符＞)}
＜变量定义及初始化＞ ::= ＜类型标识符＞＜标识符＞=＜常量＞

＜类型标识符＞ ::= int | char
＜标识符＞ ::= ＜字母＞｛＜字母＞｜＜数字＞｝
＜常量＞ ::= ＜整数＞|＜字符＞

＜整数＞ ::=［＋｜－］＜无符号整数＞
＜字符＞ ::= '＜加法运算符＞'｜'＜乘法运算符＞'｜'＜字母＞'｜'＜数字＞'
＜字母＞ ::= ＿｜a｜．．．｜z｜A｜．．．｜Z
＜数字＞ ::= ０｜１｜．．．｜９

＜无符号整数＞ ::= ＜数字＞｛＜数字＞｝
＜加法运算符＞ ::= +｜-
＜乘法运算符＞ ::= *｜/
```

3）**读语句**

```pascal
＜读语句＞ ::= scanf '('＜标识符＞')'

＜标识符＞ ::= ＜字母＞｛＜字母＞｜＜数字＞｝
＜字母＞ ::= ＿｜a｜．．．｜z｜A｜．．．｜Z
＜数字＞ ::= ０｜１｜．．．｜９
```

4）**写语句**

```pascal
＜写语句＞ ::= printf'('＜字符串＞,＜表达式＞')'| printf'('＜字符串＞')'| printf'('＜表达式＞')'

＜字符串＞ ::= "｛十进制编码为32,33,35-126的ASCII字符｝"
＜表达式＞ ::= ［＋｜－］＜项＞{＜加法运算符＞＜项＞}

＜项＞ ::= ＜因子＞{＜乘法运算符＞＜因子＞}
＜加法运算符＞ ::= +｜-

＜因子＞ ::= ＜标识符＞ | '('＜表达式＞')'｜＜整数＞|＜字符＞
＜乘法运算符＞ ::= *｜/
```

5）**赋值语句**

```pascal
＜赋值语句＞ ::= ＜标识符＞＝＜表达式＞

＜标识符＞ ::= ＜字母＞｛＜字母＞｜＜数字＞｝
＜表达式＞ ::= ［＋｜－］＜项＞{＜加法运算符＞＜项＞}

＜字母＞ ::= ＿｜a｜．．．｜z｜A｜．．．｜Z
＜数字＞ ::= ０｜１｜．．．｜９
＜项＞ ::= ＜因子＞{＜乘法运算符＞＜因子＞}
＜加法运算符＞ ::= +｜-

＜因子＞ ::= ＜标识符＞ | '('＜表达式＞')'｜＜整数＞|＜字符＞
＜乘法运算符＞ ::= *｜/
```

6）**无函数定义及调用**：nice

7）**无数组声明及引用**：nice

#### 二、注意事项

a）需自行设计**四元式中间代码**，再从中间代码生成MIPS汇编，需设计实现**输出**中间代码的有关函数，本次作业不考核，后续会有优化前后中间代码的输出及评判(输出文件命名为 学号\_姓名\_优化前/后中间代码.txt )。

b）后续的作业需参加竞速排序，需提前预留**代码优化有关的接口**，并设计方便**切换开启/关闭优化的模式**

#### 三、针对本次实验的设计

**1）四元式格式设计：**

|                           |   ans    |         x          |      op       |       y       | 基本块入口 |
| :-----------------------: | :------: | :----------------: | :-----------: | :-----------: | :--------: |
|           赋值I           |   ans    |         x          |      op       |       y       |            |
|          赋值II           |   ans    |         x          |               |               |            |
|          赋值IV           |   ans    |         x          |     addi      |       y       |            |
|          赋值III          |   ans    |                    |       -       |       y       |            |
|       if语句表达式        |  label   |         x          |     cmpOp     |       y       |   下一句   |
|         标签语句          |  label   |                    |       :       |               |     √      |
|         语句跳转          |  label   |                    |       j       |               |   下一句   |
|         函数调用          |  label   |                    |      jal      |               |   下一句   |
|        返回值设置         | <标识符> |                    |    return     |               |            |
|      把$v0返还存内存      |   ans    |                    |      $v0      |               |            |
|         返回跳转          |          |                    |      jr       |               |   下一句   |
|        开辟栈空间         |          |     size(数值)     |    spAlloc    |    (备注)     |            |
|        回收栈空间         |          |     size(数值)     |    spFree     |    (备注)     |            |
|       参数/变量压栈       |  value   |       offset       |    spPush     |    (备注)     |            |
|          $ra压栈          |          |                    |    raPush     |               |            |
|          $ra出栈          |          |                    |     raPop     |               |            |
|        从栈中取值         |   ans    |       offset       |     spGET     |    (备注)     |            |
|        向栈中存值         |  value   |       offset       |     spSET     |               |            |
| 函数中读语句将$v0存入栈中 |   $v0    |    offset(数值)    |   spSET$v0    |               |            |
|       数组赋值压栈        |  value   |       offset       |   spARRSET    |               |            |
|       数组赋值出栈        |   ans    |       offset       |   spARRGET    |               |            |
|        用数组赋值         |   ans    |       数组名       |    ARRGET     |    offset     |            |
|    数组被赋值(by变量)     |  value   |       数组名       |  ARRSETbyVAR  |  offset(VAR)  |            |
|    数组被赋值(by常量)     |  value   |       数组名       | ARRSETbyCONST | offset(CONST) |            |
|          读语句           |   ans    |                    |     read      |               |            |
|    读语句（特定类型）     |          |        type        |  ReadByType   |               |            |
|          写语句I          |          | ＜字符串＞(标识符) |     print     |  ＜表达式＞   |            |
|         写语句II          |          | ＜字符串＞(标识符) |     print     |               |            |
|         写语句III         |          |                    |     print     |  ＜表达式＞   |            |

部分中间代码对照图：

![image-20201111211947576](C:\Users\yang\AppData\Roaming\Typora\typora-user-images\image-20201111211947576.png)

**2）存储管理设计：**

​		为了优先保证基本正确性得到满足，本次实验设计先暂且牺牲一定的效率，进一步的优化放在之后再进行，本次实验暂且没有充分利用寄存器的存储功能，而是将所有变量、常量、字符串都存储在以0x10010000 (将该基地址值始终保存在 $t0 寄存器中) 为起始的内存空间中，只进行运算时，将其分别 lw 给 \$t2 和 \$t3 寄存器，并将运算结果保存在 \$t1 寄存器中，然后将 \$t1 寄存器的值 sw 到内存中或者输出。

**3）符号表设计：**

​		本次实验额外分别建立了一个**代码生成专用符号表** 和 一个**字符串记录表**，前者专门存储本次实验定义的常变量以及复杂表达式拆解过程中用到的中间变量，对于每一个表项，主要记录数据类型和在内存中相对于基地址0x10010000的地址偏移；后者记录本次所有printf语句中需要输出的字符串，对于每一个表项，主要记录该字符串的标识符、内容、在内存中的起始地址相对于基地址0x10010000的偏移值，字符串的长度(按字节计)。

​		因为本次作业是建立在错误处理通过的基础之上的，因此不会出现变、常量名未定义或者重定义的情况，因此当用到某一个量时，就在本次新建的符号表中由后往前遍历查找对应标识符的表项。

 		值得注意的是，因为在复杂表达式拆解过程当中会产生许多中间量，其标识符的命名需要避免与程序本身定义的常量、变量名冲突，唯一的办法就是采用与一般标识符不同的命名规范，我的做法是在标识符之前加一个'~'波浪符以示区分。

**4）复杂表达式的处理**

​		本次语义分析的过程与语法分析的流程相融合，采用课上所讲的语法制导属性翻译文法，对每个与表达式计算相关的递归子程序，添加参数传入与返回值，从而以递归的方式对复杂表达式进行拆解，实现起来改动较小，极为方便，稍加细心便不会出错。



## 阶段二

#### 一、本次实验新增的文法内容

1）一维数组	2）二维数组	3）函数定义与调用

#### 二、针对本次实验的设计

**1）一维数组**

之前不存在数组，因此在符号表中所有量都以4字节为单位存储，当引入数组之后，需要在语法分析阶段对数组的大小进行计算，从而确定需要开辟的内存空间大小，并将空间偏移量记录在符号表中，而对数组中某一元素进行存取的时候，如arr[i]，则计算偏移量为offset = arr.offset + 4 * i，相对来说较好处理

**2）二维数组**

二维数组的存取就复杂多了，我们需要提前记录每一个二维数组的列数col，在对于arr\[i][j]进行存取的时候，offset = arr.offset + (i * col  + j) * 4

**3) 函数定义及调用**

我采用将函数中所有的量，包括参数、定义的量、中间变量、\$ra的值，都存在\$sp 的栈中，每当调用一个函数的时候，就将所有参数压栈，出函数之后让所有参数出栈，进入函数之后将$ra的值存进栈里，每遇到一个函数中定义的量就将其存进栈中，在函数中调用其他函数之前，需要先将所有运算过程中产生的中间变量一起放进栈中，然后再将下一个函数的参数压栈，再jal到下一个函数。

因为函数中需要保存的量，其种类很多，而且需要和函数外面的量进行区分，因此我专门建立了一个函数类，用于保存每一个函数内各个量的类型、在$sp栈中的位置偏移等信息，当在函数语句中遇到一个量，优先在该函数的类中查找，若没找到，再到符号表中寻找，从而有效避免了冲突。



## 附录：

#### 四元式格式

|                           |   ans    |         x          |      op       |       y       | 基本块入口 |
| :-----------------------: | :------: | :----------------: | :-----------: | :-----------: | :--------: |
|           赋值I           |   ans    |         x          |      op       |       y       |            |
|          赋值II           |   ans    |         x          |               |               |            |
|          赋值IV           |   ans    |         x          |     addi      |       y       |            |
|          赋值III          |   ans    |                    |       -       |       y       |            |
|       if语句表达式        |  label   |         x          |     cmpOp     |       y       |   下一句   |
|         标签语句          |  label   |                    |       :       |               |     √      |
|         语句跳转          |  label   |                    |       j       |               |   下一句   |
|         函数调用          |  label   |                    |      jal      |               |   下一句   |
|        返回值设置         | <标识符> |                    |    return     |               |            |
|      把$v0返还存内存      |   ans    |                    |      $v0      |               |            |
|         返回跳转          |          |                    |      jr       |               |   下一句   |
|        开辟栈空间         |          |     size(数值)     |    spAlloc    |    (备注)     |            |
|        回收栈空间         |          |     size(数值)     |    spFree     |    (备注)     |            |
|       参数/变量压栈       |  value   |       offset       |    spPush     |    (备注)     |            |
|          $ra压栈          |          |                    |    raPush     |               |            |
|          $ra出栈          |          |                    |     raPop     |               |            |
|        从栈中取值         |   ans    |       offset       |     spGET     |    (备注)     |            |
|        向栈中存值         |  value   |       offset       |     spSET     |               |            |
| 函数中读语句将$v0存入栈中 |   $v0    |    offset(数值)    |   spSET$v0    |               |            |
|       数组赋值压栈        |  value   |       offset       |   spARRSET    |               |            |
|       数组赋值出栈        |   ans    |       offset       |   spARRGET    |               |            |
|        用数组赋值         |   ans    |       数组名       |    ARRGET     |    offset     |            |
|    数组被赋值(by变量)     |  value   |       数组名       |  ARRSETbyVAR  |  offset(VAR)  |            |
|    数组被赋值(by常量)     |  value   |       数组名       | ARRSETbyCONST | offset(CONST) |            |
|          读语句           |   ans    |                    |     read      |               |            |
|    读语句（特定类型）     |          |        type        |  ReadByType   |               |            |
|          写语句I          |          | ＜字符串＞(标识符) |     print     |  ＜表达式＞   |            |
|         写语句II          |          | ＜字符串＞(标识符) |     print     |               |            |
|         写语句III         |          |                    |     print     |  ＜表达式＞   |            |

#### 寄存器表

| REGISTER | NAME      | USAGE                     |
| -------- | --------- | ------------------------- |
| $0       | $zero     | 常量0                     |
| $1       | $at       | 保留给汇编器              |
| \$2-$3   | \$v0-​\$v1 | 函数调用返回值            |
| \$4-$7   | \$a0-​\$a3 | 函数调用参数              |
| \$8-$15  | \$t0-$t7  | 临时寄存器                |
| \$16-$23 | \$s0-$s7  | 全局寄存器                |
| \$24-$25 | \$t8-$t9  | 临时寄存器                |
| $28      | $gp       | 全局指针(Global  Pointer) |
| $29      | $sp       | 堆栈指针(Stack  Pointer)  |
| $30      | $fp       | 帧指针(Frame  Pointer)    |
| $31      | $ra       | 返回地址(return  address) |